
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Calculating latencies &#8212; Stimfit 0.16.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Loading custom text files" href="ascii.html" />
    <link rel="prev" title="Object oriented programming with Stimfit" href="introclass.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ascii.html" title="Loading custom text files"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="introclass.html" title="Object oriented programming with Stimfit"
             accesskey="P">previous</a> |</li>
    <li><a href="http://github.com/neurodroid/stimfit/wiki/Stimfit">Stimfit Homepage</a> | &nbsp; </li>
    <li><a href="http://github.com/neurodroid/stimfit" }}>Developer (Github)</a> | &nbsp; </li>
    <li><a href=../index.html>Documentation Home</a> | &nbsp; </li>

    

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">The Stimfit book of spells</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Calculating latencies</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="calculating-latencies">
<h1>Calculating latencies<a class="headerlink" href="#calculating-latencies" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p>Jose Guzman</p>
</dd>
<dt class="field-even">Updated</dt>
<dd class="field-even"><p>21 August, 2021</p>
</dd>
</dl>
<p>Very often we want to analyze data in <a class="reference external" href="http://stimfit.org">Stimfit</a> that is generated from a simulation or stored in non-stardard formats, like for example fluorescence. While <a class="reference external" href="http://stimfit.org">Stimfit</a> supports a huge variety of file formats, data from more exotic sources can be copied to a text file loaded in with a very simple Python script.</p>
<p>Examples of such cases are NEURON files, which are saved as text files as *.dat format. Alternatively, users configure custom files formats to, for example, analyze the timecourse of a fluorescent measurement with <a class="reference external" href="https://stimfit.org">Stimfit</a>.</p>
<div class="section" id="reading-neuron-text-files">
<h2>Reading NEURON text files<a class="headerlink" href="#reading-neuron-text-files" title="Permalink to this headline">¶</a></h2>
<p>NEURON allows to save a simulation in a very simple text file format. The file consists of a header with two lines containing the event that was recorded and the number of samples. After that, it is followed by the recording time and the sampled data data in a two-column format. To load such a file, we would like to skip the first two rows, and to load the adquisition time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stf</span>

<span class="k">def</span> <span class="nf">loadnrn</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads a NEURON datafile and opens a new Stimfit window</span>
<span class="sd">    with a trace with the default units (e.g ms and mV)</span>

<span class="sd">    file    -- (string) file to read</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span><span class="p">,</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">fname</span> <span class="o">=</span> <span class="n">file</span><span class="p">,</span> <span class="n">skiprows</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># the second temporal sampling point is the sampling</span>
    <span class="n">stf</span><span class="o">.</span><span class="n">new_window</span><span class="p">(</span> <span class="n">trace</span> <span class="p">)</span>
    <span class="n">stf</span><span class="o">.</span><span class="n">set_sampling_interval</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
</pre></div>
</div>
<p>You can download an example of such a file <a class="reference external" href="http://stimfit.org/doc/EPSP.dat">here</a></p>
<p>Note that the argument of the function <em>loadnrn</em> is a string containing the exact path and filename of the file that we want to load. For very lengthy paths, it can be convenient to write a small gadget that cares about the proper identification of the file. This is what we propose in the section below.</p>
</div>
<div class="section" id="custom-ascii-files-containing-fluorescence">
<h2>Custom ascii files containing fluorescence<a class="headerlink" href="#custom-ascii-files-containing-fluorescence" title="Permalink to this headline">¶</a></h2>
<p>When creating custom text files to be loaded later, it is generally convenient to take into account the folowing advices:</p>
<ol class="arabic simple">
<li><p>Use a custom extension ( generally dat, .text or similar denote files associated with specific applications).</p></li>
<li><p>Add comments that contains the experimental conditions.</p></li>
<li><p>Information about the author and date of file modification can be included in the header inside these comments.</p></li>
</ol>
<p>In the example below, a function will load a file with extension *.GoR that contains fluorescent measurements in time (acquired at 400 Hz). In addition, a small wx gadget will allow us to create a small window to select the file that we want to import.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stf</span>
</pre></div>
</div>
<p><a class="reference external" href="http://www.stimfit.org">Stimfit</a> was originally used to calculate synaptic latencies (Katz and Miledi, 1965 <a class="footnote-reference brackets" href="#katzmiledi1965" id="id4">1</a>) but now can be used to calculate synaptic latencies and latencies between events or action potentials in the same or between different channels (see <a class="reference internal" href="../manual/latency_measurements.html"><span class="doc">Latency measurements</span></a> in the <a class="reference internal" href="../manual/index.html"><span class="doc">Stimfit manual</span></a>). <a class="reference external" href="http://www.stimfit.org">Stimfit</a> also provides a very useful collection of Python functions which allow us to easily adapt the latency calculation for our particular conditions. We will use these functions to calculate the latency between two signals in two different channels (e.g. one corresponding to the soma, and another to the dendrite). We will use the object oriented programming paradigm (OOP) to solve this problem and applied it in the embedded Python shell of <a class="reference external" href="http://www.stimfit.org">Stimfit</a> .</p>
</div>
<div class="section" id="the-spike-class">
<h2>The Spike class<a class="headerlink" href="#the-spike-class" title="Permalink to this headline">¶</a></h2>
<p>We will create an object to calculate basic action potential (AP) kinetics in the current/active channel. AP peak and half-width will be calculated from a threshold (in mV/ms) defined by the user, as described in Stuart et al. (1997) <a class="footnote-reference brackets" href="#stuart1997" id="id7">2</a>. In principle, this can be easily adjusted in the <a class="reference external" href="http://www.stimfit.org">Stimfit</a> menu toolbar (see Edit-&gt;Cursor settings and select Peak tab). However, as the number of traces to analyze increase, the manipulation of the menu becomes unnecessarily repetitive and prone to errors. We  will use the object to access different AP parameters (i.e baseline, peak, half-width and maximum rise-time) all them calculated from the threshold value. Note these values are accessible in <a class="reference external" href="http://www.stimfit.org">Stimfit</a> result table (see Fig. 9 in the <a class="reference internal" href="../manual/index.html"><span class="doc">Stimfit manual</span></a>), but we will access them within Python.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once the threshold is set, it can be accessed in terms of time with <a class="reference internal" href="../stf_reference/stf.html#stf.get_threshold_time" title="stf.get_threshold_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">stf.get_threshold_time()</span></code></a>) or voltage with <a class="reference internal" href="../stf_reference/stf.html#stf.get_threshold_value" title="stf.get_threshold_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">stf.get_threshold_value()</span></code></a>.</p>
</div>
<p>Additionally, some other methods will be necessary to calculate the AP latencies. For example, we may want to calculate <strong>onset latency</strong> (i.e time difference between the beginning of the action potential in two different recordings) or <strong>peak latency</strong> (i.e difference in time between the peak of two APs in different recordings). More interestingly, we can calculate the <strong>half-width latency</strong> according to Schmidt-Hieber et al., (2008) <a class="footnote-reference brackets" href="#schmidt-hieber2008" id="id10">3</a> . In this last case, the AP latency is calculated by the time different between the times of the AP at its half-maximal amplitudes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stf</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">floor</span>

<span class="k">class</span> <span class="nc">Spike</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of methods to calculate AP properties</span>
<span class="sd">    from threshold (see Stuart et al., 1997). Note that all</span>
<span class="sd">    calculations are performed in the active/current channel!!!</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Spike instance with sampling rate and threshold</span>
<span class="sd">        measurements are performed in the current/active channel!!!</span>

<span class="sd">        Arguments:</span>
<span class="sd">        threshold   -- slope threshold to measure AP kinetics</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_thr</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="c1"># set all the necessary AP parameters at construction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateattributes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_updateattributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        update base, peak, t50, max_rise and tamplitude</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_base</span><span class="p">()</span> <span class="c1"># in Stimfit is baseline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_peak</span><span class="p">()</span> <span class="c1"># in Stimfit peak (from threshold)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t50</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_t50</span><span class="p">()</span>   <span class="c1"># in Stimfit t50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_rise</span><span class="p">()</span> <span class="c1"># in Stimfit Slope (rise)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_threshold_value</span><span class="p">()</span> <span class="c1"># in Stimit Threshold</span>

        <span class="c1"># attributes necessary to calculate latencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tonset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_threshold_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tamplitude</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t50_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_t50left</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; update current trace sampling rate,</span>
<span class="sd">        cursors position and  measurements (peak, baseline &amp; AP kinetics)</span>
<span class="sd">        according to the threshold value set at construction or when</span>
<span class="sd">        the object is called with a threshold argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set slope</span>
        <span class="n">stf</span><span class="o">.</span><span class="n">set_slope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_thr</span><span class="p">)</span> <span class="c1"># on stf v0.93 or above</span>

        <span class="c1"># update sampling rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_sampling_interval</span><span class="p">()</span>

        <span class="c1"># update cursors and AP kinetics (peak and half-width)</span>
        <span class="n">stf</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; update AP kinetic parameters to a new threshold in the</span>
<span class="sd">        current trace/channel</span>
<span class="sd">        threshold (optional)   -- the new threshold value</span>

<span class="sd">        Examples :</span>
<span class="sd">        dend = Spike(40) # set the spike threshold at 40mV/ms</span>
<span class="sd">        dend(20) # now we set the spike threshold at 20mV/ms</span>

<span class="sd">        The AP parameters will be thereby updated in the current</span>
<span class="sd">        trace/channel. This method allow us to use the same object</span>
<span class="sd">        to calculate AP latencies in different traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_thr</span> <span class="o">=</span> <span class="n">threshold</span> <span class="c1"># set a new threshold</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> <span class="c1"># update dt and sampling rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateattributes</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get baseline according to cursor position in the</span>
<span class="sd">        given current channel/trace</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_trace</span><span class="p">(</span><span class="n">trace</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">,</span><span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="n">stf</span><span class="o">.</span><span class="n">get_base_start</span><span class="p">():</span><span class="n">stf</span><span class="o">.</span><span class="n">get_base_end</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate peak measured from threshold in the current trace,</span>
<span class="sd">        (see Stuart et al (1997)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stf</span><span class="o">.</span><span class="n">set_peak_mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># a single point for the peak value</span>
        <span class="n">stf</span><span class="o">.</span><span class="n">set_peak_direction</span><span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">)</span> <span class="c1"># peak direction up</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="n">peak</span> <span class="o">=</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_peak</span><span class="p">()</span><span class="o">-</span><span class="n">stf</span><span class="o">.</span><span class="n">get_threshold_value</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">peak</span>

    <span class="k">def</span> <span class="nf">get_t50</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculates the half-width in ms in the current trace&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="c1"># current t50&#39;s difference to calculate half-width (t50)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">stf</span><span class="o">.</span><span class="n">t50right_index</span><span class="p">()</span><span class="o">-</span><span class="n">stf</span><span class="o">.</span><span class="n">t50left_index</span><span class="p">())</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="k">def</span> <span class="nf">get_max_rise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        maximum rate of rise (dV/dt) of AP in the current trace,</span>
<span class="sd">        which depends on the available Na+ conductance,</span>
<span class="sd">        see Mainen et al, 1995, Schmidt-Hieber et al, 2008</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">pmaxrise</span> <span class="o">=</span> <span class="n">stf</span><span class="o">.</span><span class="n">maxrise_index</span><span class="p">()</span> <span class="c1"># in active channel</span>

        <span class="n">trace</span> <span class="o">=</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_trace</span><span class="p">(</span><span class="n">trace</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">channel</span> <span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># current trace</span>

        <span class="n">dV</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">pmaxrise</span><span class="p">))]</span><span class="o">-</span><span class="n">trace</span><span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">pmaxrise</span><span class="p">)))]</span>

        <span class="k">return</span> <span class="n">dV</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="k">def</span> <span class="nf">get_tamplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the time a the peak in the current trace&quot;&quot;&quot;</span>

        <span class="c1">#stf.peak_index() does not update cursors!!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stf</span><span class="o">.</span><span class="n">peak_index</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="k">def</span> <span class="nf">get_t50left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the time at the half-width &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stf</span><span class="o">.</span><span class="n">t50left_index</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="k">def</span> <span class="nf">show_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the threshold value (in mV/ms) set at construction</span>
<span class="sd">        or when the object was called&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thr</span>

    <span class="k">def</span> <span class="nf">get_threshold_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the value (in y-units) at the threshold &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> <span class="c1"># stf.get_threshold_value does not update</span>
        <span class="k">return</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_threshold_value</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_threshold_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the value (in x-units) at the threshold &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">stf</span><span class="o">.</span><span class="n">get_threshold_time</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="code-commented">
<h2>Code commented<a class="headerlink" href="#code-commented" title="Permalink to this headline">¶</a></h2>
<p>Note that all methods but <strong>show_threshold()</strong> are preceded by <strong>self.update()</strong>. This is to update the sampling rate of the current trace (necessary to transform index points into time) and the position of the cursors. In this way, we are sure that every function will return the values according to the current trace and the update position of the cursors.</p>
<p>Because we want to group all the AP parameters (i.e baseline, peak, half-width and max rise) of a single trace together, we set the object attributes to the following values;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_updateattributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_base</span><span class="p">()</span> <span class="c1"># in Stimfit is baseline</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_peak</span><span class="p">()</span> <span class="c1"># in Stimfit peak (from threshold)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t50</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_t50</span><span class="p">()</span>  <span class="c1"># in Stimfit t50</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">max_rise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_rise</span><span class="p">()</span> <span class="c1"># in Stimfit slope (rise)</span>

    <span class="c1"># attributes necessary to calculate latencies</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_threshold_time</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tamplitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tamplitude</span><span class="p">()</span>
</pre></div>
</div>
<p>These values refer to the trace present in the current Stimfit window when the object was created. This will allow us to store them for future calculations.</p>
<p>Note for example, that if we create an object with threshold 40</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myspike</span> <span class="o">=</span> <span class="n">Spike</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>and move after that to another trace, we could calculate the difference between the peaks of the previous and present trace as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myspike</span><span class="o">.</span><span class="n">peak</span> <span class="o">-</span> <span class="n">myspike</span><span class="o">.</span><span class="n">get_peak</span><span class="p">()</span>
</pre></div>
</div>
<p>the former will give the peak value when in the trace where the object was created, and the later will return the peak in the current trace.</p>
<p>Additionally, we can decide to change the threshold value of the AP in a trace. For that, we can type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myspike</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>And now the Spike attributes will be updated with the new threshold in the current trace. The function __call__ allows to call the object with a given argument, and we used it to set a different threshold and update the object attributes.</p>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>To use this class we have to create an object in the current trace with a threshold value as argument. Do not forget to set both baseline and peak cursors before creating the object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span> <span class="o">=</span> <span class="n">spells</span><span class="o">.</span><span class="n">Spike</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can calculate the parameters with the methods available to this object. Note that these values change as we change the trace (i.e, we do not need to type update() or use <a class="reference internal" href="../stf_reference/stf.html#stf.measure" title="stf.measure"><code class="xref py py-func docutils literal notranslate"><span class="pre">stf.measure()</span></code></a>). This means that the method soma.get_base() will return different values if we call it in different traces or move the cursors. Compare the values obtained with the functions with the corresponding values in the result table of <a class="reference external" href="http://www.stimfit.org">Stimfit</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span><span class="o">.</span><span class="n">get_base</span><span class="p">()</span> <span class="c1"># correspond to baseline in the results table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span><span class="o">.</span><span class="n">get_peak</span><span class="p">()</span> <span class="c1"># correspond to Peak (from threshold) in the results table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span><span class="o">.</span><span class="n">get_t50</span><span class="p">()</span> <span class="c1"># correspond to t50 in the results table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span><span class="o">.</span><span class="n">get_max_rise</span><span class="p">()</span> <span class="c1"># correspond to slope (rise) in the results table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span><span class="o">.</span><span class="n">get_threshold_value</span><span class="p">()</span> <span class="c1"># correspond to Threshold in the results table</span>
</pre></div>
</div>
<p>Additionally, we have methods like <strong>get_tamplitude()</strong>, <strong>get_threshold()</strong> and <strong>get_threshold_time()</strong> to calculate latencies with different methods. For example, if we have two different Spike objects, one corresponding to the soma and the other corresponding to the dendrite, we could calculate calculate the latencies with the 3 following methods.</p>
<ul class="simple">
<li><p>1.- <strong>Onset latency:</strong> this is the latency between the beginning of 2 APs. We can calculate it as follows:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span> <span class="o">=</span> <span class="n">spells</span><span class="o">.</span><span class="n">Spike</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="c1"># threshold of somatic AP is 50mV/ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stf</span><span class="o">.</span><span class="n">set_channel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># move to channel 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dend</span> <span class="o">=</span> <span class="n">spells</span><span class="o">.</span><span class="n">Spike</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># threshold for dendritic AP is 20mV/ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">latency</span> <span class="o">=</span> <span class="n">dend</span><span class="o">.</span><span class="n">tonset</span> <span class="o">-</span> <span class="n">soma</span><span class="o">.</span><span class="n">tonset</span>
</pre></div>
</div>
<ul class="simple">
<li><p>2.- <strong>Peak latency:</strong> this is the latency between the peaks of 2 APs. Similarly to the previous calculate, we can use:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">latency</span> <span class="o">=</span> <span class="n">dend</span><span class="o">.</span><span class="n">tpeak</span> <span class="o">-</span> <span class="n">soma</span><span class="o">.</span><span class="n">tpeak</span>
</pre></div>
</div>
<ul class="simple">
<li><p>3.- <strong>T50 latency:</strong> this method is included in the Edit option of the <a class="reference external" href="http://www.stimfit.org">Stimfit</a> menu toolbar. However, this menu assumes that both thresholds are the same. If we want to set different latencies for the calculation of the t50 latency, we can the Spike property called t50left:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">latency</span> <span class="o">=</span> <span class="n">dend</span><span class="o">.</span><span class="n">t50_left</span> <span class="o">-</span> <span class="n">soma</span><span class="o">.</span><span class="n">t50_left</span>
</pre></div>
</div>
<p>You can find the class Spike described above in your current <a class="reference external" href="http://www.stimfit.org">Stimfit</a> version. To use it, you can import it from the spells module with the following command;</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spells</span> <span class="kn">import</span> <span class="n">Spike</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">soma</span> <span class="o">=</span> <span class="n">Spike</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dend</span> <span class="o">=</span> <span class="n">Spike</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># in a different trace/window</span>
</pre></div>
</div>
<p>Additionally, the spells module contains a function which creates a result table (see Figure bellow) with all the AP kinetic parameters described previously, and the latency calculated with the 3 methods described here. Once the soma and dend objects are created with the class Spike, we can use the latency function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spells</span> <span class="kn">import</span> <span class="n">latency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">latency</span><span class="p">(</span><span class="n">soma</span><span class="p">,</span><span class="n">dend</span><span class="p">)</span> <span class="c1"># both soma and dend are Spike objects</span>
</pre></div>
</div>
<p>note that this function assumes that you set the cursors property in your trace, and that the dendritic and somatic AP are already initialized and contains the AP attributes of some trace.</p>
<blockquote>
<div><div class="figure align-center" id="id14">
<img alt="result table returned by AP.calc()" src="../_images/APmodule.png" />
<p class="caption"><span class="caption-text">Result table returned by the AP.calc() function.</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the figure, the cell highlighted represent the latency calculated as the difference between the times at the half-width of the AP (as we did previously), and NOT the difference between the half-widths!!!</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="katzmiledi1965"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>Katz B, Miledi R (1965). The measurement of synaptic delay, and the time course of acetylcholine release at the neuromuscular junction. Proc R Soc Lond B Biol Sci. 161, 483-495</p>
</dd>
<dt class="label" id="stuart1997"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>Stuart G, Schiller J, Sakmann B (1997). Action potential initiation and propagation in rat neocortical pyramidal neurons. J Physiol. 505, 617-632</p>
</dd>
<dt class="label" id="schmidt-hieber2008"><span class="brackets"><a class="fn-backref" href="#id10">3</a></span></dt>
<dd><p>Schmidt-Hieber C, Jonas P, Bischofberger J (2008). Action potential initiation and propagation in hippocampal mossy fibre axons. J Physiol. 586, 1849-1857.</p>
</dd>
<dt class="label" id="mainen1995"><span class="brackets">4</span></dt>
<dd><p>Mainen ZF, Joerges J, Huguenard JR, Sejnowski TJ (1995). A model of spike initiation in neocortical pyramidal neurons. Neuron 15, 1427-1439.</p>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/stimfit_128.png" alt="Logo"/>
            </a></p>
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Calculating latencies</a><ul>
<li><a class="reference internal" href="#reading-neuron-text-files">Reading NEURON text files</a></li>
<li><a class="reference internal" href="#custom-ascii-files-containing-fluorescence">Custom ascii files containing fluorescence</a></li>
<li><a class="reference internal" href="#the-spike-class">The Spike class</a></li>
<li><a class="reference internal" href="#code-commented">Code commented</a></li>
<li><a class="reference internal" href="#usage">Usage</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="introclass.html"
                        title="previous chapter">Object oriented programming with Stimfit</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ascii.html"
                        title="next chapter">Loading custom text files</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/stimfit_128.png" alt="Logo"/>
            </a></p>
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Calculating latencies</a><ul>
<li><a class="reference internal" href="#reading-neuron-text-files">Reading NEURON text files</a></li>
<li><a class="reference internal" href="#custom-ascii-files-containing-fluorescence">Custom ascii files containing fluorescence</a></li>
<li><a class="reference internal" href="#the-spike-class">The Spike class</a></li>
<li><a class="reference internal" href="#code-commented">Code commented</a></li>
<li><a class="reference internal" href="#usage">Usage</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="introclass.html"
                        title="previous chapter">Object oriented programming with Stimfit</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ascii.html"
                        title="next chapter">Loading custom text files</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christoph Schmidt-Hieber.
      Last updated on 21 August, 2021.
    </div>
  </body>
</html>